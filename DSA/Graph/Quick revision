-> Quick Revision Notes for Breadth-First Search (BFS)
    [Required : Queue, Visited Array]
    [Time Complexity : O(V+E) || V = vertices, E = edges]
    [Space Complexity : O(b^d)]
    BFS is an algorithm for traversing or searching tree or graph data structures level by level.
    Utilizes a queue to track the nodes to be explored next.
    Visits nodes in layers (level order traversal).
    Finds the shortest path in an unweighted graph.
    
    Algorithm Steps
    Initialization: Start with a queue containing the starting node and a visited set.
    Process Loop: While the queue is not empty:
    Dequeue the front node.
    Process the node (e.g., print its value).
    For each unvisited neighbor, mark it as visited and enqueue it.
    End Condition: The process continues until all reachable nodes are explored.

    Space Complexity: O(b^d), where b is the branching factor and d is the depth of the shallowest goal node.
    Time Complexity: O(V+E) where V is the number of vertices and E is the number of edges.

-> Quick Revision Notes for Depth-First Search (DFS)
    [Required : Recursion, Visited Array]
    [Time Complexity : O(V+E) || V = vertices, E = edges]
    [Space Complexity : O(V)]
    DFS is an algorithm for traversing or searching tree or graph structures, exploring as deep as possible along each branch before backtracking.
    Time Complexity: O(V+E), where V is the number of vertices and E is the number of edges.
    Space Complexity: O(V) (due to recursion or stack usage).
    
    Algorithm:
    Start at a node.
    Mark the node as visited.
    Recursively visit all unvisited adjacent nodes.
    Backtrack when no adjacent unvisited nodes are left.
    
    Applications:
    Pathfinding (e.g., in mazes).
    Cycle detection in graphs.
    Topological sorting in DAGs.
    Finding connected components in graphs.
    Solving puzzles like N-Queens, Sudoku.

-> Quick Revision Notes for Topological Sort:
    [Required : DAG's, Recursion, Stack, Visited Array]
    [Time Complexity : O(V+E) || V = vertices, E = edges]
    [Space Complexity : O(V)]
    Topological Sorting is an ordering of vertices in a directed graph where for every directed edge u -> v, vertex u comes before v in the ordering.
    Applicable only for Directed Acyclic Graphs (DAGs), i.e., graphs without cycles.
    Use Cases: Task scheduling, course prerequisite problems, resolving dependencies between tasks, etc.
    
    DFS-based Topological Sort:
    Perform DFS from each unvisited node.
    Post-order: Once DFS completes for a node (i.e., all its descendants are visited), push it onto a stack.
    The topological order is obtained by popping all nodes from the stack (the first node out is the last in topological order).
    Cycle Detection: If a back edge is found, a cycle exists, meaning topological sorting isn't possible.
    Time Complexity: O(V + E), where V is the number of vertices, and E is the number of edges.
    
    Steps:
    Initialize an empty stack and a visited array.
    For each unvisited node, run DFS.
    After visiting all nodes in the DFS, add the node to the stack.
    Once all nodes are visited, pop from the stack to get the topological sort.
    
    Key Points:
    DFS focuses on out-degree.
    Cycle detection requires maintaining a recursion stack.

-> Quick Revision Notes for Kahn's Algorithm (BFS-based Topological Sort):
    [Required : DAG's, Queue, In-degree Array,]
    [Time Complexity : O(V+E) || V = vertices, E = edges]
    [Space Complexity : O(V)]
    In-degree concept: For each node, track the number of incoming edges.
    Start with all nodes having in-degree 0 (no dependencies).
    Process nodes in BFS fashion:
    Remove the node from the graph.
    Reduce the in-degree of all its neighbors.
    Add neighbors with in-degree 0 to the processing queue.
    
    Cycle Detection: If the number of processed nodes is less than the total number of nodes, the graph contains a cycle.
    Steps:
    Compute in-degree of all vertices.
    Enqueue all vertices with in-degree 0.
    While the queue is not empty, remove a vertex, add it to the topological order, and reduce in-degree of its neighbors. If a neighbor’s in-degree becomes 0, enqueue it.
    If there are nodes left unprocessed at the end, the graph contains a cycle.
    Time Complexity: O(V + E).
    
    Key Points:
    Kahn’s Algorithm is based on in-degree.
    Naturally handles cycle detection.
    Processes nodes level by level in BFS order.
    
    Comparison of DFS and Kahn's Algorithm:
    DFS: Depth-first exploration, adds nodes to the stack as they finish processing.
    Kahn's Algorithm: Level-order (BFS) processing based on in-degrees.
    Cycle Detection: Both algorithms can detect cycles, but Kahn's algorithm handles it more naturally by detecting unprocessed nodes.
